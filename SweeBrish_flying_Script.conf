# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: ui_cu_autoconf_construct_flying

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
        
handlers:
    unit:
        start:
            lua: |
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(0)
                
                jdecode = json.decode
                
                -- USER DEFINABLE VARIABLES
                --local x = -21406.8382 --export
                --local y = 308538.5280 --export
                --local z = 10891.3520 --export
                AutopilotStrength = 1 --export  -- How strongly autopilot tries to point at a target
                DampingMultiplier = 1 --export: How strongly autopilot dampens when nearing the correct orientation
                AutopilotTargetIndex = 1
                destId = 11

                Travel = false
                autoAlign = false


                -- Functions
                -- Interplanetary helper
                function ShowInterplanetaryPanel()
                    if panelInterplanetary == nil then
                        panelInterplanetary = system.createWidgetPanel("Interplanetary Helper")

                        widgetCurBrakeDistance = system.createWidget(panelInterplanetary, "value")
                        widgetCurBrakeDistanceText = system.createData('{"label": "Cur Brake Distance", "value": "N/A", "unit":""}')
                        system.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)
                        
                        widgetCurBrakeTime = system.createWidget(panelInterplanetary, "value")
                        widgetCurBrakeTimeText = system.createData('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')
                        system.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)
                        
                        widgetTarget = system.createWidget(panelInterplanetary, "value")
                        widgetTargetText = system.createData('{"label": "Destination", "value": "N/A", "unit":""}')
                        system.addDataToWidget(widgetTargetText, widgetTarget)
                        
                        widgetDistance = system.createWidget(panelInterplanetary, "value")
                        widgetDistanceText = system.createData('{"label": "Distance", "value": "N/A", "unit":""}')
                        system.addDataToWidget(widgetDistanceText, widgetDistance)
                        
                        widgetAlign = system.createWidget(panelInterplanetary, "value")
                        widgetAlignText = system.createData('{"label": "Auto Aligning", "value": "OFF", "unit":""}')
                        system.addDataToWidget(widgetAlignText, widgetAlign)
                        
                        widgetTravel = system.createWidget(panelInterplanetary, "value")
                        widgetTravelText = system.createData('{"label": "Travel", "value": "OFF", "unit":""}')
                        system.addDataToWidget(widgetTravelText, widgetTravel)
                    end
                end

                function estimateBrakingTime (force, restMass, currentSpeed, targetSpeed)
                    local F, m0, v0, v_target = force, restMass, currentSpeed, targetSpeed
                    local c = 30000 / 3.6 -- m/s
                          -- v'(t)=F / (m0 / sqrt(1 - ( (v(t))/c)**2) ), v(0)=v0
                          -- v(t)=c sin((F t)/(c m0) + sin^(-1)(v0/c))
                          -- solve [ c sin((F t)/(c m0) + sin^(-1)(v0/c)) = k ] for t
                          -- t = (c m0 sin^(-1)(k/c) - c m0 sin^(-1)(v0/c))/F
                    return (c * m0 * math.asin(v_target / c) - c * m0 * math.asin(v0 / c) ) / F
                    end

                function estimateBrakingDistance (force, restMass, currentSpeed, brakeTime)
                    local F, m0, v0, u = force, restMass, currentSpeed, brakeTime
                    local c = 30000 / 3.6 -- m/s
                          -- integrate [ c sin((F t)/(c m0) + sin^(-1)(v0/c)) dt ] t=0..u
                          -- d = (c (c m0 sqrt(1 - v0^2/c^2) - c m0 sqrt(1 - v0^2/c^2) cos((F u)/(c m0)) + m0 v0 sin((F u)/(c m0))))/F
                          -- a = c m0 sqrt(1 - v0^2/c^2); b = (F u)/(c m0); d = (c (a - a cos(b) + m0 v0 sin(b)))/F
                    local a = c * m0 * math.sqrt(1 - v0 * v0 / c / c)
                    local b = (F * u) / (c * m0)
                    return (c * (a - a * math.cos(b) + m0 * v0 * math.sin(b))) / F
                    end

                function FormatTimeString(seconds)
                    local hours = math.floor(seconds/3600)
                    local minutes = math.floor(seconds/60%60)
                    local seconds = math.floor(seconds%60)
                    if seconds < 0 or hours < 0 or minutes < 0 then
                        return "0s"
                    end
                    if hours > 0 then 
                        return hours .. "h " .. minutes .. "m " .. seconds .. "s"
                    elseif minutes > 0 then
                        return minutes .. "m " ..seconds.."s"
                    else
                        return seconds.."s"
                    end
                end

                function round(num, numDecimalPlaces)
                  local mult = 10^(numDecimalPlaces or 0)
                  return math.floor(num * mult + 0.5) / mult
                end

                function getDistanceDisplayString2(distance)
                    local su = distance > 100000
                    local result = ""
                    if su then
                        -- Convert to SU
                        result = round(distance/1000/200,2) .. " SU"
                    elseif distance < 1000 then
                        result = round(distance,2) .. " M"
                    else
                        -- Convert to KM
                        result = round(distance/1000,2) .. " KM"
                    end
                    return result
                end

                function getMagnitudeInDirection(vector, direction)
                    --return vec3(vector):project_on(vec3(direction)):len()
                    vector = vec3(vector)
                    direction = vec3(direction):normalize()
                    local result = vector*direction -- To preserve sign, just add them I guess
                    return result.x + result.y + result.z
                end

                function AlignToWorldVector(vector, tolerance)
                    -- Sets inputs to attempt to point at the autopilot target
                    -- Meant to be called from Update or Tick repeatedly
                    if tolerance == nil then
                        tolerance = alignmentTolerance
                    end
                    vector = vec3(vector):normalize()
                    local targetVec = (vec3(core.getConstructWorldOrientationForward()) - vector)
                    local yawAmount = -getMagnitudeInDirection(targetVec, core.getConstructWorldOrientationRight()) * AutopilotStrength
                    local pitchAmount = -getMagnitudeInDirection(targetVec, core.getConstructWorldOrientationUp()) * AutopilotStrength
                    
                    system.print(yawAmount)
                    system.print(pitchAmount)
                    
                    yawInput2 = yawInput2 - (yawAmount - PreviousYawAmount) * DampingMultiplier
                    pitchInput2 = pitchInput2 + (pitchAmount - PreviousPitchAmount) * DampingMultiplier
                    PreviousYawAmount = yawAmount
                    PreviousPitchAmount = pitchAmount
                    -- Return true or false depending on whether or not we're aligned
                    if math.abs(yawAmount) < tolerance and math.abs(pitchAmount) < tolerance then
                        return true
                    end
                    return false
                end        
                
                
                -- Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom with minor modifications
                function Atlas()
                    return {
                    [0] = {
                        [0]={
                            GM=0,
                            bodyId=0,
                            center={-21406.8382,308538.5280,10891.3520},
                            name='Upper Shard',
                            planetarySystemId=0,
                            radius=0
                            },
                        [1]={
                            GM=6930729684,
                            bodyId=1,
                            center={x=17465536.000,y=22665536.000,z=-34464.000},
                            name='Madis',
                            planetarySystemId=0,
                            radius=44300
                            },
                        [2]={
                            GM=157470826617,
                            bodyId=2,
                            center={x=-8.000,y=-8.000,z=-126303.000},
                            name='Alioth',
                            planetarySystemId=0,
                            radius=126068
                            },
                        [3]={
                            GM=11776905000,
                            bodyId=3,
                            center={x=29165536.000,y=10865536.000,z=65536.000},
                            name='Thades',
                            planetarySystemId=0,
                            radius=49000
                            },
                        [4]={
                            GM=14893847582,
                            bodyId=4,
                            center={x=-13234464.000,y=55765536.000,z=465536.000},
                            name='Talemai',
                            planetarySystemId=0,
                            radius=57450
                            },
                        [5]={
                            GM=16951680000,
                            bodyId=5,
                            center={x=-43534464.000,y=22565536.000,z=-48934464.000},
                            name='Feli',
                            planetarySystemId=0,
                            radius=60000
                            },
                        [6]={
                            GM=10502547741,
                            bodyId=6,
                            center={x=52765536.000,y=27165538.000,z=52065535.000},
                            name='Sicari',
                            planetarySystemId=0,
                            radius=51100
                            },
                        [7]={
                            GM=13033380591,
                            bodyId=7,
                            center={x=58665538.000,y=29665535.000,z=58165535.000},
                            name='Sinnen',
                            planetarySystemId=0,
                            radius=54950
                            },
                        [8]={
                            GM=18477723600,
                            bodyId=8,
                            center={x=80865538.000,y=54665536.000,z=-934463.940},
                            name='Teoma',
                            planetarySystemId=0,
                            radius=62000
                            },
                        [9]={
                            GM=18606274330,
                            bodyId=9,
                            center={x=-94134462.000,y=12765534.000,z=-3634464.000},
                            name='Jago',
                            planetarySystemId=0,
                            radius=61590
                            },
                        [10]={
                            GM=78480000,
                            bodyId=10,
                            center={x=17448118.224,y=22966846.286,z=143078.820},
                            name='Madis Moon 1',
                            planetarySystemId=0,
                            radius=10000
                            },
                        [11]={
                            GM=237402000,
                            bodyId=11,
                            center={x=17194626.000,y=22243633.880,z=-214962.810},
                            name='Madis Moon 2',
                            planetarySystemId=0,
                            radius=11000
                            },
                        [12]={
                            GM=265046609,
                            bodyId=12,
                            center={x=17520614.000,y=22184730.000,z=-309989.990},
                            name='Madis Moon 3',
                            planetarySystemId=0,
                            radius=15005
                            },
                        [21]={
                            GM=2118960000,
                            bodyId=21,
                            center={x=457933.000,y=-1509011.000,z=115524.000},
                            name='Alioth Moon 1',
                            planetarySystemId=0,
                            radius=30000
                            },
                        [22]={
                            GM=2165833514,
                            bodyId=22,
                            center={x=-1692694.000,y=729681.000,z=-411464.000},
                            name='Alioth Moon 4',
                            planetarySystemId=0,
                            radius=30330
                            },
                        [26]={
                            GM=68234043600,
                            bodyId=26,
                            center={x=-1404835.000,y=562655.000,z=-285074.000},
                            name='Sanctuary',
                            planetarySystemId=0,
                            radius=83400
                            },
                        [30]={
                            GM=211564034,
                            bodyId=30,
                            center={x=29214402.000,y=10907080.695,z=433858.200},
                            name='Thades Moon 1',
                            planetarySystemId=0,
                            radius=14002
                            },
                        [31]={
                            GM=264870000,
                            bodyId=31,
                            center={x=29404193.000,y=10432768.000,z=19554.131},
                            name='Thades Moon 2',
                            planetarySystemId=0,
                            radius=15000
                            },
                        [40]={
                            GM=141264000,
                            bodyId=40,
                            center={x=-13503090.000,y=55594325.000,z=769838.640},
                            name='Talemai Moon 2',
                            planetarySystemId=0,
                            radius=12000
                            },
                        [41]={
                            GM=106830900,
                            bodyId=41,
                            center={x=-12800515.000,y=55700259.000,z=325207.840},
                            name='Talemai Moon 3',
                            planetarySystemId=0,
                            radius=11000
                            },
                        [42]={
                            GM=264870000,
                            bodyId=42,
                            center={x=-13058408.000,y=55781856.000,z=740177.760},
                            name='Talemai Moon 1',
                            planetarySystemId=0,
                            radius=15000
                            },
                        [50]={
                            GM=499917600,
                            bodyId=50,
                            center={x=-43902841.780,y=22261034.700,z=-48862386.000},
                            name='Feli Moon 1',
                            planetarySystemId=0,
                            radius=14000
                            },
                        [70]={
                            GM=396912600,
                            bodyId=70,
                            center={x=58969616.000,y=29797945.000,z=57969449.000},
                            name='Sinnen Moon 1',
                            planetarySystemId=0,
                            radius=17000
                            },
                        [100]={
                            GM=13975172474,
                            bodyId=100,
                            center={x=98865536.000,y=-13534464.000,z=-934461.990},
                            name='Lacobus',
                            planetarySystemId=0,
                            radius=55650
                            },
                        [101]={
                            GM=264870000,
                            bodyId=101,
                            center={x=98905288.170,y=-13950921.100,z=-647589.530},
                            name='Lacobus Moon 3',
                            planetarySystemId=0,
                            radius=15000
                            },
                        [102]={
                            GM=444981600,
                            bodyId=102,
                            center={x=99180968.000,y=-13783862.000,z=-926156.400},
                            name='Lacobus Moon 1',
                            planetarySystemId=0,
                            radius=18000
                            },
                        [103]={
                            GM=211503600,
                            bodyId=103,
                            center={x=99250052.000,y=-13629215.000,z=-1059341.400},
                            name='Lacobus Moon 2',
                            planetarySystemId=0,
                            radius=14000
                            },
                        [110]={
                            GM=9204742375,
                            bodyId=110,
                            center={x=14165536.000,y=-85634465.000,z=-934464.300},
                            name='Symeon',
                            planetarySystemId=0,
                            radius=49050
                            },
                        [120]={
                            GM=7135606629,
                            bodyId=120,
                            center={x=2865536.700,y=-99034464.000,z=-934462.020},
                            name='Ion',
                            planetarySystemId=0,
                            radius=44950
                            },
                        [121]={
                            GM=106830900,
                            bodyId=121,
                            center={x=2472916.800,y=-99133747.000,z=-1133582.800},
                            name='Ion Moon 1',
                            planetarySystemId=0,
                            radius=11000
                            },
                        [122]={
                            GM=176580000,
                            bodyId=122,
                            center={x=2995424.500,y=-99275010.000,z=-1378480.700},
                            name='Ion Moon 2',
                            planetarySystemId=0,
                            radius=15000
                            }  
                        }
                    }
                end

                function tablelength(T)
                  local count = 0
                  for _ in pairs(T) do count = count + 1 end
                  return count
                end

                function UpdateAutopilotTarget()
                    -- So the indices are weird.  I think we need to do a pairs
                    if AutopilotTargetIndex == 0 then
                        AutopilotTargetName = "None"
                        AutopilotTargetPlanet = nil
                        return true
                    end
                    local count = 0
                    for k,v in pairs(Atlas()[0]) do
                        count = count + 1
                        if count == AutopilotTargetIndex then
                            destId = v.bodyId
                            return true
                        end
                    end
                end

                function IncrementAutopilotTargetIndex()
                    AutopilotTargetIndex = AutopilotTargetIndex + 1
                    if AutopilotTargetIndex >  tablelength(Atlas()[0]) then 
                        AutopilotTargetIndex = 1
                    end
                    UpdateAutopilotTarget()
                end

                function DecrementAutopilotTargetIndex()
                    AutopilotTargetIndex = AutopilotTargetIndex - 1
                    if AutopilotTargetIndex < 1 then 
                        AutopilotTargetIndex = tablelength(Atlas()[0])
                    end
                    UpdateAutopilotTarget()
                end

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                placeRadar = true
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                -- if gyro ~= nil then gyro.show() end

                ShowInterplanetaryPanel()

                                
                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end
                unit.setTimer("oneSecond", 1)
                unit.setTimer("Fast", 0.1)
                
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()
        
        tick:
            args: ["oneSecond"]
            lua: |
                -- Timer for evaluation every 1 second

                
                --data collection
                local speed = vec3(core.getWorldVelocity()):len() -- m/s
                local mass = core.getConstructMass() -- kg
                local maxBrake = -jdecode(unit.getData()).maxBrake
                local pos = vec3(core.getConstructWorldPos())
                                
                destination  = vec3(Atlas()[0][destId]["center"])
                Dist = (destination - pos):len() --meters
                targetVector = (destination-pos):normalize()
                
                -- landing gear control
                if speed < 10 then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end
                                              
                -- max speed stop engine control 
                if speed > 8333 then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) end
                
                brakingTime = estimateBrakingTime(maxBrake, mass, speed, 0)
                brakingDistance = estimateBrakingDistance(maxBrake, mass, speed, brakingTime)

                if autoAlign then
                    AlignToWorldVector(targetVector, 0.001)
                end    

                if Travel then
                    if Atlas()[0][destId]["radius"] == 0 then
                        safeDist = 10000
                    else
                        safeDist = Atlas()[0][destId]["radius"] + 100000
                    end
                    if (brakingDistance + safeDist)  > Dist then
                        brakeInput = 1
                        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                        Travel = false
                    end
                end
                
                system.updateData(widgetCurBrakeDistanceText, '{"label": "Cur Brake Distance", "value": "' .. getDistanceDisplayString2(brakingDistance) .. '", "unit":""}')
                system.updateData(widgetCurBrakeTimeText, '{"label": "Cur Brake Time", "value": "' .. FormatTimeString(brakingTime) .. '", "unit":""}')
                system.updateData(widgetTargetText, '{"label": "Destination", "value": "' .. Atlas()[0][destId]["name"] ..'", "unit":""}')
                system.updateData(widgetDistanceText, '{"label": "Distance", "value": "' .. getDistanceDisplayString2(Dist) ..'", "unit":""}')
                if autoAlign then
                    system.updateData(widgetAlignText, '{"label": "Auto Aligning", "value": "ON", "unit":""}')
                else
                    system.updateData(widgetAlignText, '{"label": "Auto Aligning", "value": "OFF", "unit":""}')
                end    
                if Travel then
                    system.updateData(widgetTravelText, '{"label": "Travel", "value": "ON", "unit":""}')
                else
                    system.updateData(widgetTravelText, '{"label": "Travel", "value": "OFF", "unit":""}')
                end  


        tick:
            args: ["Fast"]
            lua: |
                -- Timer 10 Hz update
                if autoAlign then
                    AlignToWorldVector(targetVector, 0.001)
                end                    
    system:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput =1
                pitchInput2 = 0
                rollInput2 = 0
                yawInput2 = 0
                PreviousYawAmount = 0
                PreviousPitchAmount = 0
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + pitchInput2 + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + rollInput2 + system.getControlDeviceYawInput()
                local finalYawInput = yawInput + yawInput2 - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: Nav:update()

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: if brakeInput == 0 then brakeInput = 1 else brakeInput = 0 end

        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)

        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        actionStart:
            args: [warp]
            lua: if warpdrive ~= nil then warpdrive.activateWarp() end
            
        actionStart:
            args: [option1]
            lua: IncrementAutopilotTargetIndex()
            
        actionStart:
            args: [option2]
            lua: DecrementAutopilotTargetIndex()
            
        actionStart:
            args: [option3]
            lua: if autoAlign then 
                    autoAlign = false
                    pitchInput2 = 0
                    yawInput2 = 0
                else 
                    autoAlign = true
                end
                
        actionStart:
            args: [option4]
            lua: if Travel then 
                    Travel = false
                    pitchInput2 = 0
                    yawInput2 = 0
                else 
                    Travel = true
                end